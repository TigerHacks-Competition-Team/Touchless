[{"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\index.js":"1","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\App.js":"2","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\reportWebVitals.js":"3","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\Components\\Menu.js":"4","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\MLModel.js":"5"},{"size":517,"mtime":1607791452264,"results":"6","hashOfConfig":"7"},{"size":3772,"mtime":1607809661476,"results":"8","hashOfConfig":"7"},{"size":375,"mtime":1607791452264,"results":"9","hashOfConfig":"7"},{"size":2556,"mtime":1607809584239,"results":"10","hashOfConfig":"7"},{"size":3551,"mtime":1607809584240,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1p8qr17",{"filePath":"15","messages":"16","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"14"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"22"},{"filePath":"23","messages":"24","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"25","usedDeprecatedRules":"14"},"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\index.js",[],["26","27"],"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\App.js",["28","29","30"],"import React from 'react';\r\nimport Menu from './Components/Menu';\r\nimport * as tf from \"@tensorflow/tfjs\";\r\nimport \"./MLModel\";\r\nimport MLModel from \"./MLModel\";\r\n\r\n\r\nclass App extends React.Component {\r\n  videoRef = React.createRef()\r\n  canvasRef = React.createRef()\r\n\r\n  async componentDidMount() {\r\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\r\n      const webCamPromise = navigator.mediaDevices\r\n        .getUserMedia({\r\n          audio: false,\r\n          video: {\r\n            facingMode: \"user\",\r\n          }\r\n        })\r\n        .then((stream) => {\r\n          window.stream = stream\r\n          this.videoRef.current.srcObject = stream\r\n          return new Promise((resolve, reject) => {\r\n            this.videoRef.current.onloadedmetadata = () => {\r\n              resolve()\r\n            }\r\n          })\r\n        })\r\n      /*\r\n      const model = new MLModel(\"web_model/model.json\");\r\n      const modelPromise = model.load();\r\n      //const modelPromise = cocoSsd.load();\r\n      /*const modelPromise = tf.loadFrozenModel(\r\n        \"https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@1.0.0\"\r\n      );\r\n      console.log(\"getting model\");\r\n      Promise.all([modelPromise, webCamPromise])\r\n        .then((values) => {\r\n          console.log(\"got model: \");\r\n          this.model = model;\r\n          this.detectFrame(this.videoRef.current);\r\n        })\r\n        .catch((error) => {\r\n          console.error(error);\r\n        });*/\r\n    }\r\n  }\r\n\r\n\r\n\r\ndetectFrame = (video) => {\r\n    this.model.infer(video, 1, 0).then((predictions) => {\r\n      //console.log(\"adding to frame: \" + JSON.stringify(predictions[0].bbox));\r\n      this.renderPredictions(predictions);\r\n      requestAnimationFrame(() => {\r\n        this.detectFrame(video);\r\n      });\r\n    });\r\n  };\r\n\r\nrenderPredictions = (predictions) => {\r\n    const classes = [\"Hand\"];\r\n    const ctx = this.canvasRef.current.getContext(\"2d\");\r\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n    // Font options.\r\n    const font = \"16px sans-serif\";\r\n    ctx.font = font;\r\n    ctx.textBaseline = \"top\";\r\n    console.log(\"predictions: \" + predictions.length);\r\n    predictions.forEach((prediction) => {\r\n      const x = prediction.bbox[0];\r\n      const y = prediction.bbox[1];\r\n      const width = prediction.bbox[2];\r\n      const height = prediction.bbox[3];\r\n      console.log(\r\n        \"x: \" + x + \"; y: \" + y + \"; width: \" + width + \"; height: \" + height\r\n      );\r\n      // Draw the bounding box.\r\n      ctx.strokeStyle = \"#00FFFF\";\r\n      ctx.lineWidth = 4;\r\n      ctx.strokeRect(x, y, width, height);\r\n      // Draw the label background.\r\n      ctx.fillStyle = \"#00FFFF\";\r\n      const textWidth = ctx.measureText(\r\n        classes[prediction.class] + \" %\" + prediction.score\r\n      ).width;\r\n      const textHeight = parseInt(font, 10); // base 10\r\n      ctx.fillRect(x, y, textWidth + 4, textHeight + 4);\r\n    });\r\n\r\n    predictions.forEach((prediction) => {\r\n      const x = prediction.bbox[0];\r\n      const y = prediction.bbox[1];\r\n      // Draw the text last to ensure it's on top.\r\n      ctx.fillStyle = \"#000000\";\r\n      ctx.fillText(prediction.class + \" %\" + prediction.score * 100, x, y);\r\n    });\r\n  };\r\n  render(){\r\n  return (\r\n    <div className=\"App\">\r\n      <p style={styles.header}>Touchless</p>\r\n      <video\r\n        className=\"size\"\r\n        autoPlay\r\n        playsInline\r\n        muted\r\n        ref={this.videoRef}\r\n        width=\"600\"\r\n        height=\"500\"\r\n      />\r\n      <canvas\r\n        className=\"size\"\r\n        ref={this.canvasRef}\r\n        width=\"600\"\r\n        height=\"500\"\r\n      />\r\n      <Menu />\r\n    </div>\r\n  );\r\n  }\r\n}\r\n\r\nconst styles = {\r\n  header: {\r\n    textAlign: \"center\",\r\n    color: '#3DC4BB',\r\n  },\r\n}\r\n\r\nexport default App;\r\n","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\reportWebVitals.js",[],"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\Components\\Menu.js",["31"],"import React, { Component } from 'react';\r\n\r\nclass Subcategory extends React.Component{\r\n    render(){\r\n        return (\r\n                <div style={styles.subCategoryDiv}>\r\n                  <button style={styles.menu}\r\n                          onClick={this.props.onClick}>\r\n                  {this.props.data.name}</button>\r\n                    {this.props.toRender && this.props.data.menuItems.map(element => (\r\n                      <div>\r\n                        <p style={styles.menuItems}>\r\n                        {element}\r\n                        </p>\r\n                      </div>\r\n                    ))}\r\n                </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n      super(props);\r\n        this.state = {\r\n            renderedSubmenu: 0,\r\n            data:\r\n            [\r\n                {\r\n                name: \"Breakfast\",\r\n                menuItems: [\"Pancake\", \"Cheese\"],\r\n                },\r\n                {\r\n                name: \"Lunch\",\r\n                menuItems: [\"Sandwich\", \"Soup\"],\r\n                },\r\n                {\r\n                name: \"Dinner\",\r\n                menuItems:[\"Pasta\", \"Chicken\"],\r\n                }\r\n\r\n            ]  \r\n        }\r\n    }\r\n\r\n    openCategory = (nthCategory) => {\r\n      let numCategories = this.state.data.length\r\n      if (nthCategory > numCategories) {\r\n        console.log(\"Invalid Category\")\r\n        return\r\n      }\r\n      this.setState({\r\n        renderedSubmenu: nthCategory,\r\n      })\r\n      console.log(this.state.renderedSubmenu)\r\n    }\r\n  \r\n    render() {\r\n    \r\n          \r\n      return (\r\n       <div>\r\n           <Subcategory data={this.state.data[0]} \r\n                        toRender={this.state.renderedSubmenu === 0}\r\n                        onClick={() => this.openCategory(0)}/>\r\n           <Subcategory data={this.state.data[1]} toRender={this.state.renderedSubmenu === 1}\r\n                        onClick={() => this.openCategory(1)}/>\r\n           <Subcategory data={this.state.data[2]} toRender={this.state.renderedSubmenu === 2}\r\n                        onClick={() => this.openCategory(2)}/>\r\n       </div>\r\n      );\r\n    }\r\n  }\r\n\r\n\r\nexport default Menu;\r\n\r\nconst styles = {\r\n    subCategoryDiv: {\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      flexDirection: \"column\",\r\n    },\r\n    menu: {\r\n      textAlign: \"center\",\r\n      color: '#3DC4BB',\r\n      fontSize: \"1.5em\",\r\n    },\r\n    menuItems: {\r\n        margin: \"2px\",\r\n        padding: \"1px\",\r\n        textAlign: \"center\"\r\n    }\r\n  }","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\MLModel.js",["32"],"import * as tf from \"@tensorflow/tfjs\";\r\n\r\nconst viewPort = [640, 480];\r\n\r\nexport default class MLModel {\r\n  constructor(props) {\r\n    this.model = props;\r\n  }\r\n\r\n  load = async () => {\r\n    return new Promise(async (resolve) => {\r\n      this.model = await tf.loadGraphModel(this.model);\r\n      resolve();\r\n    });\r\n  };\r\n\r\n  infer = async (img, maxNumBoxes, minScore) => {\r\n    img = tf.browser.fromPixels(img);\r\n    img = tf.image.resizeBilinear(img, [416, 416]);\r\n    img = img.expandDims(0);\r\n    let imageData = img.arraySync();\r\n    img = tf.tensor(imageData, [1, 416, 416, 3], \"int32\");\r\n    const height = img.shape[1] * (viewPort[1] / 416);\r\n    const width = img.shape[2] * (viewPort[0] / 416);\r\n\r\n    // model returns two tensors:\r\n    // 1. box classification score with shape of [1, 1917, 90]\r\n    // 2. box location with shape of [1, 1917, 1, 4]\r\n    // where 1917 is the number of box detectors, 90 is the number of classes.\r\n    // and 4 is the four coordinates of the box.\r\n    console.log(\"this.model: \" + this.model);\r\n    const result = await this.model.executeAsync(img, [\r\n      \"detection_scores\",\r\n      \"detection_classes\",\r\n      \"detection_boxes\",\r\n    ]);\r\n\r\n    if (result != null) {\r\n      const scores = result[0].dataSync();\r\n      const boxes = result[2].dataSync();\r\n      var clss = result[1].arraySync();\r\n      clss = clss[0];\r\n\r\n      // clean the webgl tensors\r\n      //batched.dispose();\r\n      //tf.dispose(result);\r\n\r\n      const [maxScores, classes] = this.calculateMaxScores(\r\n        scores,\r\n        boxes.length,\r\n        clss.length\r\n      );\r\n\r\n      const prevBackend = tf.getBackend();\r\n      // run post process in cpu\r\n      if (tf.getBackend() === \"webgl\") {\r\n        tf.setBackend(\"cpu\");\r\n      }\r\n      var boxes2 = tf.tensor2d(boxes, [result[2].shape[1], result[2].shape[2]]);\r\n      const indexTensor = tf.tidy(() => {\r\n        return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes);\r\n      });\r\n      const indexes = indexTensor.arraySync();\r\n      indexTensor.dispose();\r\n\r\n      // restore previous backend\r\n      if (prevBackend !== tf.getBackend()) {\r\n        tf.setBackend(prevBackend);\r\n      }\r\n\r\n      return this.buildDetectedObjects(\r\n        width,\r\n        height,\r\n        boxes2.arraySync(),\r\n        maxScores,\r\n        indexes,\r\n        clss\r\n      );\r\n    } else {\r\n      tf.dispose(result);\r\n      return [];\r\n    }\r\n  };\r\n\r\n  buildDetectedObjects = (width, height, boxes, scores, indexes, classes) => {\r\n    const count = indexes.length;\r\n    const objects = [];\r\n    for (let i = 0; i < count; i++) {\r\n      const bbox = boxes[indexes[i]];\r\n      const minY = bbox[0] * height;\r\n      const minX = bbox[1] * width;\r\n      const maxY = bbox[2] * height;\r\n      const maxX = bbox[3] * width;\r\n      bbox[0] = minX;\r\n      bbox[1] = minY;\r\n      bbox[2] = maxX - minX;\r\n      bbox[3] = maxY - minY;\r\n      objects.push({\r\n        bbox: bbox,\r\n        class: classes[indexes[i]],\r\n        score: scores[indexes[i]],\r\n      });\r\n    }\r\n    return objects;\r\n  };\r\n\r\n  calculateMaxScores = (scores, numBoxes, numClasses) => {\r\n    const maxes = [];\r\n    const classes = [];\r\n    for (let i = 0; i < numBoxes; i++) {\r\n      let max = Number.MIN_VALUE;\r\n      let index = -1;\r\n      for (let j = 0; j < numClasses; j++) {\r\n        if (scores[i * numClasses + j] > max) {\r\n          max = scores[i * numClasses + j];\r\n          index = j;\r\n        }\r\n      }\r\n      maxes[i] = max;\r\n      classes[i] = index;\r\n    }\r\n    return [maxes.slice(0, 100), classes];\r\n  };\r\n}\r\n",{"ruleId":"33","replacedBy":"34"},{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","severity":1,"message":"38","line":3,"column":13,"nodeType":"39","messageId":"40","endLine":3,"endColumn":15},{"ruleId":"37","severity":1,"message":"41","line":5,"column":8,"nodeType":"39","messageId":"40","endLine":5,"endColumn":15},{"ruleId":"37","severity":1,"message":"42","line":14,"column":13,"nodeType":"39","messageId":"40","endLine":14,"endColumn":26},{"ruleId":"37","severity":1,"message":"43","line":1,"column":17,"nodeType":"39","messageId":"40","endLine":1,"endColumn":26},{"ruleId":"37","severity":1,"message":"44","line":48,"column":25,"nodeType":"39","messageId":"40","endLine":48,"endColumn":32},"no-native-reassign",["45"],"no-negated-in-lhs",["46"],"no-unused-vars","'tf' is defined but never used.","Identifier","unusedVar","'MLModel' is defined but never used.","'webCamPromise' is assigned a value but never used.","'Component' is defined but never used.","'classes' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]