[{"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\index.js":"1","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\App.js":"2","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\reportWebVitals.js":"3","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\Components\\Menu.js":"4","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\MLModel.js":"5"},{"size":517,"mtime":1607791452264,"results":"6","hashOfConfig":"7"},{"size":3587,"mtime":1607809944225,"results":"8","hashOfConfig":"7"},{"size":375,"mtime":1607791452264,"results":"9","hashOfConfig":"7"},{"size":2556,"mtime":1607809584239,"results":"10","hashOfConfig":"7"},{"size":3551,"mtime":1607809584240,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"1p8qr17",{"filePath":"15","messages":"16","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"14"},"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\index.js",[],["25","26"],"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\App.js",["27"],"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\reportWebVitals.js",[],"C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\Components\\Menu.js",["28"],"import React, { Component } from 'react';\r\n\r\nclass Subcategory extends React.Component{\r\n    render(){\r\n        return (\r\n                <div style={styles.subCategoryDiv}>\r\n                  <button style={styles.menu}\r\n                          onClick={this.props.onClick}>\r\n                  {this.props.data.name}</button>\r\n                    {this.props.toRender && this.props.data.menuItems.map(element => (\r\n                      <div>\r\n                        <p style={styles.menuItems}>\r\n                        {element}\r\n                        </p>\r\n                      </div>\r\n                    ))}\r\n                </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\nclass Menu extends React.Component {\r\n    constructor(props) {\r\n      super(props);\r\n        this.state = {\r\n            renderedSubmenu: 0,\r\n            data:\r\n            [\r\n                {\r\n                name: \"Breakfast\",\r\n                menuItems: [\"Pancake\", \"Cheese\"],\r\n                },\r\n                {\r\n                name: \"Lunch\",\r\n                menuItems: [\"Sandwich\", \"Soup\"],\r\n                },\r\n                {\r\n                name: \"Dinner\",\r\n                menuItems:[\"Pasta\", \"Chicken\"],\r\n                }\r\n\r\n            ]  \r\n        }\r\n    }\r\n\r\n    openCategory = (nthCategory) => {\r\n      let numCategories = this.state.data.length\r\n      if (nthCategory > numCategories) {\r\n        console.log(\"Invalid Category\")\r\n        return\r\n      }\r\n      this.setState({\r\n        renderedSubmenu: nthCategory,\r\n      })\r\n      console.log(this.state.renderedSubmenu)\r\n    }\r\n  \r\n    render() {\r\n    \r\n          \r\n      return (\r\n       <div>\r\n           <Subcategory data={this.state.data[0]} \r\n                        toRender={this.state.renderedSubmenu === 0}\r\n                        onClick={() => this.openCategory(0)}/>\r\n           <Subcategory data={this.state.data[1]} toRender={this.state.renderedSubmenu === 1}\r\n                        onClick={() => this.openCategory(1)}/>\r\n           <Subcategory data={this.state.data[2]} toRender={this.state.renderedSubmenu === 2}\r\n                        onClick={() => this.openCategory(2)}/>\r\n       </div>\r\n      );\r\n    }\r\n  }\r\n\r\n\r\nexport default Menu;\r\n\r\nconst styles = {\r\n    subCategoryDiv: {\r\n      display: \"flex\",\r\n      justifyContent: \"center\",\r\n      flexDirection: \"column\",\r\n    },\r\n    menu: {\r\n      textAlign: \"center\",\r\n      color: '#3DC4BB',\r\n      fontSize: \"1.5em\",\r\n    },\r\n    menuItems: {\r\n        margin: \"2px\",\r\n        padding: \"1px\",\r\n        textAlign: \"center\"\r\n    }\r\n  }","C:\\Users\\maxwe\\Documents\\WilsonHacks\\Touchless\\src\\MLModel.js",["29"],"import * as tf from \"@tensorflow/tfjs\";\r\n\r\nconst viewPort = [640, 480];\r\n\r\nexport default class MLModel {\r\n  constructor(props) {\r\n    this.model = props;\r\n  }\r\n\r\n  load = async () => {\r\n    return new Promise(async (resolve) => {\r\n      this.model = await tf.loadGraphModel(this.model);\r\n      resolve();\r\n    });\r\n  };\r\n\r\n  infer = async (img, maxNumBoxes, minScore) => {\r\n    img = tf.browser.fromPixels(img);\r\n    img = tf.image.resizeBilinear(img, [416, 416]);\r\n    img = img.expandDims(0);\r\n    let imageData = img.arraySync();\r\n    img = tf.tensor(imageData, [1, 416, 416, 3], \"int32\");\r\n    const height = img.shape[1] * (viewPort[1] / 416);\r\n    const width = img.shape[2] * (viewPort[0] / 416);\r\n\r\n    // model returns two tensors:\r\n    // 1. box classification score with shape of [1, 1917, 90]\r\n    // 2. box location with shape of [1, 1917, 1, 4]\r\n    // where 1917 is the number of box detectors, 90 is the number of classes.\r\n    // and 4 is the four coordinates of the box.\r\n    console.log(\"this.model: \" + this.model);\r\n    const result = await this.model.executeAsync(img, [\r\n      \"detection_scores\",\r\n      \"detection_classes\",\r\n      \"detection_boxes\",\r\n    ]);\r\n\r\n    if (result != null) {\r\n      const scores = result[0].dataSync();\r\n      const boxes = result[2].dataSync();\r\n      var clss = result[1].arraySync();\r\n      clss = clss[0];\r\n\r\n      // clean the webgl tensors\r\n      //batched.dispose();\r\n      //tf.dispose(result);\r\n\r\n      const [maxScores, classes] = this.calculateMaxScores(\r\n        scores,\r\n        boxes.length,\r\n        clss.length\r\n      );\r\n\r\n      const prevBackend = tf.getBackend();\r\n      // run post process in cpu\r\n      if (tf.getBackend() === \"webgl\") {\r\n        tf.setBackend(\"cpu\");\r\n      }\r\n      var boxes2 = tf.tensor2d(boxes, [result[2].shape[1], result[2].shape[2]]);\r\n      const indexTensor = tf.tidy(() => {\r\n        return tf.image.nonMaxSuppression(boxes2, maxScores, maxNumBoxes);\r\n      });\r\n      const indexes = indexTensor.arraySync();\r\n      indexTensor.dispose();\r\n\r\n      // restore previous backend\r\n      if (prevBackend !== tf.getBackend()) {\r\n        tf.setBackend(prevBackend);\r\n      }\r\n\r\n      return this.buildDetectedObjects(\r\n        width,\r\n        height,\r\n        boxes2.arraySync(),\r\n        maxScores,\r\n        indexes,\r\n        clss\r\n      );\r\n    } else {\r\n      tf.dispose(result);\r\n      return [];\r\n    }\r\n  };\r\n\r\n  buildDetectedObjects = (width, height, boxes, scores, indexes, classes) => {\r\n    const count = indexes.length;\r\n    const objects = [];\r\n    for (let i = 0; i < count; i++) {\r\n      const bbox = boxes[indexes[i]];\r\n      const minY = bbox[0] * height;\r\n      const minX = bbox[1] * width;\r\n      const maxY = bbox[2] * height;\r\n      const maxX = bbox[3] * width;\r\n      bbox[0] = minX;\r\n      bbox[1] = minY;\r\n      bbox[2] = maxX - minX;\r\n      bbox[3] = maxY - minY;\r\n      objects.push({\r\n        bbox: bbox,\r\n        class: classes[indexes[i]],\r\n        score: scores[indexes[i]],\r\n      });\r\n    }\r\n    return objects;\r\n  };\r\n\r\n  calculateMaxScores = (scores, numBoxes, numClasses) => {\r\n    const maxes = [];\r\n    const classes = [];\r\n    for (let i = 0; i < numBoxes; i++) {\r\n      let max = Number.MIN_VALUE;\r\n      let index = -1;\r\n      for (let j = 0; j < numClasses; j++) {\r\n        if (scores[i * numClasses + j] > max) {\r\n          max = scores[i * numClasses + j];\r\n          index = j;\r\n        }\r\n      }\r\n      maxes[i] = max;\r\n      classes[i] = index;\r\n    }\r\n    return [maxes.slice(0, 100), classes];\r\n  };\r\n}\r\n",{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},{"ruleId":"34","severity":1,"message":"35","line":3,"column":13,"nodeType":"36","messageId":"37","endLine":3,"endColumn":15},{"ruleId":"34","severity":1,"message":"38","line":1,"column":17,"nodeType":"36","messageId":"37","endLine":1,"endColumn":26},{"ruleId":"34","severity":1,"message":"39","line":48,"column":25,"nodeType":"36","messageId":"37","endLine":48,"endColumn":32},"no-native-reassign",["40"],"no-negated-in-lhs",["41"],"no-unused-vars","'tf' is defined but never used.","Identifier","unusedVar","'Component' is defined but never used.","'classes' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]